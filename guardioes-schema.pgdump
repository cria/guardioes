--
-- PostgreSQL database dump
--

-- Dumped from database version 13.2
-- Dumped by pg_dump version 13.2

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: topology; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA topology;


ALTER SCHEMA topology OWNER TO postgres;

--
-- Name: SCHEMA topology; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA topology IS 'PostGIS Topology schema';


--
-- Name: postgis; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA public;


--
-- Name: EXTENSION postgis; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION postgis IS 'PostGIS geometry, geography, and raster spatial types and functions';


--
-- Name: postgis_topology; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgis_topology WITH SCHEMA topology;


--
-- Name: EXTENSION postgis_topology; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION postgis_topology IS 'PostGIS topology spatial types and functions';


--
-- Name: unaccent; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS unaccent WITH SCHEMA public;


--
-- Name: EXTENSION unaccent; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION unaccent IS 'text search dictionary that removes accents';


--
-- Name: category_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.category_type AS ENUM (
    'guardiao',
    'especialista',
    'admin',
    'super'
);


ALTER TYPE public.category_type OWNER TO postgres;

--
-- Name: education_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.education_type AS ENUM (
    'fundamental',
    'medio',
    'superior',
    'pos'
);


ALTER TYPE public.education_type OWNER TO postgres;

--
-- Name: habit_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.habit_type AS ENUM (
    'arvore',
    'arbusto',
    'erva',
    'epifita',
    'trepadeira',
    'parasita',
    'nda'
);


ALTER TYPE public.habit_type OWNER TO postgres;

--
-- Name: ident_status_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.ident_status_type AS ENUM (
    'invalido',
    'pendente',
    'valido'
);


ALTER TYPE public.ident_status_type OWNER TO postgres;

--
-- Name: image_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.image_type AS ENUM (
    'interacao',
    'planta'
);


ALTER TYPE public.image_type OWNER TO postgres;

--
-- Name: interaction_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.interaction_type AS ENUM (
    'construindo_ninho',
    'coletando_alimento_flor',
    'coletando_resina',
    'dormindo',
    'copulando',
    'comendo_cortando_folhas',
    'comendo_cortando_petalas',
    'sugando_seiva',
    'apoiando',
    'nda'
);


ALTER TYPE public.interaction_type OWNER TO postgres;

--
-- Name: status_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.status_type AS ENUM (
    'inativo',
    'pendente',
    'ativo'
);


ALTER TYPE public.status_type OWNER TO postgres;

--
-- Name: ascii(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ascii(str text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$

BEGIN
        str := lower(str);
        str := translate(str,'áéíóúâêîôûãõàèìòùäëïöüçýÿyñ','aeiouaeiouaoaeiouaeiouciiin');
        str := regexp_replace(str,'[^abcdefghijklmnopqrstuvwxyz ]','','g');

        str := regexp_replace(str,      '([abcdefghijklmnopqrstuvwxyz])(\1+)',        '\1','g');

        str := trim(str);

        return str;
END;
$$;


ALTER FUNCTION public.ascii(str text) OWNER TO postgres;

--
-- Name: def_version_trigger_function(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.def_version_trigger_function() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        update def_version set version = version + 1;
        return new;
End;
$$;


ALTER FUNCTION public.def_version_trigger_function() OWNER TO postgres;

--
-- Name: eventdateupdate(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.eventdateupdate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

declare x text[];
begin
        select into x regexp_matches(NEW.eventdate,'(\d+)[^\d](\d+)[^\d](\d+)');

        NEW.eventDay   = x[1]::int;
        NEW.eventMonth = x[2]::int;
        NEW.eventYear  = x[3]::int;
        return NEW;
End;
$$;


ALTER FUNCTION public.eventdateupdate() OWNER TO postgres;

--
-- Name: fixinitcap(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.fixinitcap(in_st text) RETURNS text
    LANGUAGE plpgsql
    AS $$

declare var_st              text;

Begin

   var_st = initcap(in_st);

   var_st = regexp_replace(var_st,' D(a|e|o|as|os) ',' d\1 ','g');

   return trim(var_st);
End;
$$;


ALTER FUNCTION public.fixinitcap(in_st text) OWNER TO postgres;

--
-- Name: simplify(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.simplify(in_st text) RETURNS text
    LANGUAGE plpgsql
    AS $$

declare var_st              text;

Begin

   var_st = lower(in_st);
   var_st := translate(var_author,'áéíóúâêîôûãõàèìòùäëïöüçýÿyñ','aeiouaeiouaoaeiouaeiouciiin');

   if (var_st is null or var_author = '') then
        return '';
   end if;

   var_st = regexp_replace(var_author,'\\s+','','g');
   var_st = regexp_replace(var_author,'[^a-z0-9]+','','g');

   return trim(var_st);
End;
$$;


ALTER FUNCTION public.simplify(in_st text) OWNER TO postgres;

--
-- Name: updatecounts(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.updatecounts() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

delete from counts;

-- =======================================================================================================
-- rec_noid geral		usar o campo scientificName e nao genus.

insert into counts (key,kingdom,num)
	select 'rec_noid','plantae',count(1) from record r
	where not exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'plantae' and i.scientificname != '' and i.status != 'invalido');

insert into counts (key,kingdom,num)
	select 'rec_noid','animalia',count(1) from record r
	where not exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'animalia' and i.scientificname != '' and i.status != 'invalido');

insert into counts (key,kingdom,taxgrp,num)
	select 'rec_noid','animalia',taxgrp,count(1) from record r
	where not exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'animalia' and i.scientificname != '' and i.status != 'invalido')
	group by 1,2,3;

-- =======================================================================================================
-- rec_noid por usuario		usar o campo scientificName e nao genus.

insert into counts (user_id,key,kingdom,num)
	select user_id,'rec_noid','plantae',count(1) from record r
	where not exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'plantae' and i.scientificname != '' and i.status != 'invalido') group by 1;

insert into counts (user_id,key,kingdom,num)
	select user_id,'rec_noid','animalia',count(1) from record r
	where not exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'animalia' and i.scientificname != '' and i.status != 'invalido') group by 1;

insert into counts (user_id,key,kingdom,taxgrp,num)
	select user_id,'rec_noid','animalia',taxgrp,count(1) from record r
	where not exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'animalia' and i.scientificname != '' and i.status != 'invalido')
	group by 1,2,3,4;

-- =======================================================================================================
-- espécies identificadas 
-- spp_id on scientifiName		usar o campo scientificName e nao genus.

insert into counts (user_id,key,kingdom,num)
	select user_id,'spp_id','plantae',count(1) from record r
	where exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'plantae' and i.scientificname != '' and i.status != 'invalido') group by 1;

insert into counts (user_id,key,kingdom,num)
	select user_id,'spp_id','animalia',count(1) from record r
	where exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'animalia' and i.scientificname != '' and i.status != 'invalido') group by 1;

insert into counts (user_id,key,kingdom,taxgrp,num)
	select user_id,'spp_id','animalia',taxgrp,count(1) from record r
	where exists (select i.id from ident i where i.record_id = r.id and i.kingdom = 'animalia' and i.scientificname != '' and i.status != 'invalido')
	group by 1,2,3,4;

-- =======================================================================================================
-- rec_noval 
-- totals
insert into counts (key,kingdom,num)
	select 'rec_noval','animalia',count(1) from record r
	where (select i.status from ident i where i.record_id = r.id and kingdom = 'animalia' order by dateidentified desc limit 1) = 'pendente' group by 1,2;

insert into counts (key,kingdom,num)
	select 'rec_noval','plantae',count(1) from record r
	where (select i.status from ident i where i.record_id = r.id and kingdom = 'plantae' order by dateidentified desc limit 1) = 'pendente' group by 1,2;

insert into counts (key,kingdom,taxgrp,num)
	select 'rec_noval','animalia',taxgrp,count(1) from record r
	where (select i.status from ident i where i.record_id = r.id and kingdom = 'animalia' order by dateidentified desc limit 1) = 'pendente' group by 1,2,3;


-- by user 

insert into counts (user_id,key,kingdom,num)
	select r.user_id,'rec_noval','animalia',count(1) from record r
	where (select i.status from ident i where i.record_id = r.id and kingdom = 'animalia' order by dateidentified desc limit 1) = 'pendente' group by 1,2,3;

insert into counts (user_id,key,kingdom,num)
	select r.user_id,'rec_noval','plantae',count(1) from record r
	where (select i.status from ident i where i.record_id = r.id and kingdom = 'plantae' order by dateidentified desc limit 1) = 'pendente' group by 1,2,3;

insert into counts (user_id,key,kingdom,taxgrp,num)
	select r.user_id,'rec_noval','animalia',taxgrp,count(1) from record r
	where (select i.status from ident i where i.record_id = r.id and kingdom = 'animalia' order by dateidentified desc limit 1) = 'pendente' group by 1,2,3,4;

-- =======================================================================================================
-- identifications per user

insert into counts (user_id,key,kingdom,num)
select identifiedby_id,'idents_by',kingdom,count(1) from ident i where (i.scientificname != '' or i.family != '') and i.status != 'invalido' group by 1,2,3;

-- identifications visible by general public
insert into counts (user_id,key,kingdom,num)
select identifiedby_id,'pub_idents_by',kingdom,count(1) from ident_view i where (i.scientificname != '' or i.family != '') group by 1,2,3;

-- total per kingdom

insert into counts (user_id,key,kingdom,num)
select 0,'num_ident',kingdom,sum(num) from counts where key = 'idents_by' group by 1,2,3;

-- total all

insert into counts (user_id,key,num)
select 0,'num_ident',sum(num) from counts where key = 'num_ident' and user_id = 0 group by 1,2;

-- =======================================================================================================
-- images counts by type

insert into counts (user_id,key,kingdom,num)
	select user_id,'num_image',image_of,count(1) from image group by 1,2,3;

insert into counts (key,kingdom,num)
	select 'num_image',image_of,count(1) from image group by 1,2;

-- images counts total

insert into counts (user_id,key,num)
	select 0,'num_image',count(1) from image group by 1,2;
-- =======================================================================================================
-- records by user

insert into counts (user_id,key,num)
select user_id,'num_rec',count(1) from record group by 1;

-- records total

insert into counts (user_id,key,num)
select 0,'num_rec',count(1) from record group by 1;

-- =======================================================================================================
-- number of users by category

insert into counts (user_id,key,kingdom,num)
select 0,'num_user',category,count(1) from users group by 1,2,3;

--- ver melhor como somar...



        return old;
End;
$$;


ALTER FUNCTION public.updatecounts() OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: counts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.counts (
    user_id integer DEFAULT 0 NOT NULL,
    key text DEFAULT ''::text NOT NULL,
    kingdom text DEFAULT ''::text NOT NULL,
    taxgrp text DEFAULT ''::text NOT NULL,
    num integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.counts OWNER TO postgres;

--
-- Name: TABLE counts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.counts IS 'Armazena contadores gerais do sistema como número de registros, identificações, imagens, etc., por usuário e totais. É atualizada através de trigger sempre que tabelas envolvidas nos números são alteradas.';


--
-- Name: COLUMN counts.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.counts.user_id IS 'Chave do usuário (0 para estatísticas globais).';


--
-- Name: COLUMN counts.key; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.counts.key IS 'Tipo de contador.
Tabela atualizada por trigger com a função updateCounts().
num_ident = número de identificações por reino e total
num_image = número de imagens por reino, usuário e total
num_rec = número de registros por usuário e total
num_user = número de usuários por categoria e total
idents_by = número total de identificações feitas por usuário e reino
pub_idents_by = número de identificações atuais (current id) por usuário e reino
rec_noid = número de registros sem identificação por reino, usuário e grupo taxonômico
rec_noval = número de registros que têm identificações aguardando validação, por usuário, reino, grupo taxonômico e total
spp_id = número de espécies identificadas nos registros enviados pelo usuário por usuário, reino e grupo taxonômico';


--
-- Name: COLUMN counts.kingdom; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.counts.kingdom IS 'Todos os contadores da tabela são feitas para plantas ou animais envolvidos. O campo kingdom define a qual dos reinos se refere o contador';


--
-- Name: COLUMN counts.taxgrp; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.counts.taxgrp IS 'Identifica contadores por expertise de especialistas (vide tabela def_expertise)';


--
-- Name: COLUMN counts.num; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.counts.num IS 'Total de registros.';


--
-- Name: def_expertise; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.def_expertise (
    id integer NOT NULL,
    key text NOT NULL,
    grupo text DEFAULT 'animal'::text NOT NULL
);


ALTER TABLE public.def_expertise OWNER TO postgres;

--
-- Name: TABLE def_expertise; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.def_expertise IS 'Definições dos grupos de atuação válidos para especialistas cadastrados no sistema.';


--
-- Name: COLUMN def_expertise.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.def_expertise.id IS 'Chave primária.';


--
-- Name: COLUMN def_expertise.key; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.def_expertise.key IS 'Nome do tipo de organismo (planta, formiga, lagarto, etc.).';


--
-- Name: COLUMN def_expertise.grupo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.def_expertise.grupo IS 'Reino (animalia ou plantae).';


--
-- Name: def_habit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.def_habit (
    id integer NOT NULL,
    key text NOT NULL
);


ALTER TABLE public.def_habit OWNER TO postgres;

--
-- Name: TABLE def_habit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.def_habit IS 'Definições dos hábitos das plantas válidos.';


--
-- Name: COLUMN def_habit.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.def_habit.id IS 'Chave primária.';


--
-- Name: COLUMN def_habit.key; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.def_habit.key IS 'Hábito da planta:
arvore
arbusto
erva
epifita
trepadeira
parasita
nda';


--
-- Name: def_interaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.def_interaction (
    id integer NOT NULL,
    key text NOT NULL,
    strength integer NOT NULL
);


ALTER TABLE public.def_interaction OWNER TO postgres;

--
-- Name: TABLE def_interaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.def_interaction IS 'Definições dos tipos de interação animal-planta válidos.';


--
-- Name: COLUMN def_interaction.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.def_interaction.id IS 'Chave primária.';


--
-- Name: COLUMN def_interaction.key; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.def_interaction.key IS 'Tipo de interação:
coletando_alimento_flor
se_alimentando_fruto
construindo_ninho
coletando_resina
dormindo
copulando
apoiando
comendo_cortando_folhas
comendo_cortando_petalas
sugando_seiva
morando
nda';


--
-- Name: def_version; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.def_version (
    version integer
);


ALTER TABLE public.def_version OWNER TO postgres;

--
-- Name: TABLE def_version; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.def_version IS 'Controla modificações feitas nas tabelas def_expertise, def_habit, def_interaction para que sejam atualizadas no app, quando necessário.';


--
-- Name: COLUMN def_version.version; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.def_version.version IS 'Versão atual das definições.';


--
-- Name: device; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.device (
    id integer NOT NULL,
    user_id integer NOT NULL,
    appcode text NOT NULL
);


ALTER TABLE public.device OWNER TO postgres;

--
-- Name: TABLE device; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.device IS 'Dispositivo (celular, tablet) utilizado por usuário do sistema.';


--
-- Name: COLUMN device.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.device.id IS 'Chave primária.';


--
-- Name: COLUMN device.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.device.user_id IS 'Chave do usuário.';


--
-- Name: COLUMN device.appcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.device.appcode IS 'Código único gerado e fornecido pelo dispositivo.';


--
-- Name: device_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.device_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.device_id_seq OWNER TO postgres;

--
-- Name: device_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.device_id_seq OWNED BY public.device.id;


--
-- Name: expertises; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.expertises (
    user_id integer NOT NULL,
    expertise_id integer NOT NULL
);


ALTER TABLE public.expertises OWNER TO postgres;

--
-- Name: TABLE expertises; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.expertises IS 'Especialidade de usuário do sistema.';


--
-- Name: COLUMN expertises.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.expertises.user_id IS 'Chave do usuário.';


--
-- Name: COLUMN expertises.expertise_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.expertises.expertise_id IS 'Chave da especialidade.';


--
-- Name: expertises_view; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.expertises_view AS
 SELECT e.user_id,
    e.expertise_id,
    x.key AS expertise
   FROM (public.expertises e
     LEFT JOIN public.def_expertise x ON ((e.expertise_id = x.id)));


ALTER TABLE public.expertises_view OWNER TO postgres;

--
-- Name: ident; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ident (
    id bigint NOT NULL,
    record_id integer,
    user_id integer,
    identifiedby_id integer,
    dateidentified timestamp with time zone DEFAULT now(),
    validatedby_id integer,
    datevalidated timestamp with time zone,
    scientificname text DEFAULT ''::text,
    scientificnameauthorship text DEFAULT ''::text,
    kingdom text DEFAULT ''::text,
    phylum text DEFAULT ''::text,
    class text DEFAULT ''::text,
    ordem text DEFAULT ''::text,
    family text DEFAULT ''::text,
    genus text DEFAULT ''::text,
    subgenus text DEFAULT ''::text,
    specificepithet text DEFAULT ''::text,
    taxonrank text DEFAULT ''::text,
    infraspecificepithet text DEFAULT ''::text,
    vernacularname text DEFAULT ''::text,
    identificationremarks text DEFAULT ''::text,
    status public.ident_status_type DEFAULT 'pendente'::public.ident_status_type NOT NULL
);


ALTER TABLE public.ident OWNER TO postgres;

--
-- Name: TABLE ident; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ident IS 'Identificações dos animais e plantas.';


--
-- Name: COLUMN ident.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.id IS 'Chave primária.';


--
-- Name: COLUMN ident.record_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.record_id IS 'Registro de observação associado.';


--
-- Name: COLUMN ident.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.user_id IS 'Chave do usuário';


--
-- Name: COLUMN ident.identifiedby_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.identifiedby_id IS 'Identificado por.';


--
-- Name: COLUMN ident.dateidentified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.dateidentified IS 'Data da identificação.';


--
-- Name: COLUMN ident.validatedby_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.validatedby_id IS 'Validado por.';


--
-- Name: COLUMN ident.datevalidated; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.datevalidated IS 'Data da validação.';


--
-- Name: COLUMN ident.scientificname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.scientificname IS 'Nome científico.';


--
-- Name: COLUMN ident.scientificnameauthorship; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.scientificnameauthorship IS 'Autor do nome científico.';


--
-- Name: COLUMN ident.kingdom; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.kingdom IS 'Reino.';


--
-- Name: COLUMN ident.phylum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.phylum IS 'Filo.';


--
-- Name: COLUMN ident.class; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.class IS 'Classe.';


--
-- Name: COLUMN ident.ordem; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.ordem IS 'Ordem.';


--
-- Name: COLUMN ident.family; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.family IS 'Família.';


--
-- Name: COLUMN ident.genus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.genus IS 'Gênero.';


--
-- Name: COLUMN ident.subgenus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.subgenus IS 'Subgênero.';


--
-- Name: COLUMN ident.specificepithet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.specificepithet IS 'Epíteto específico.';


--
-- Name: COLUMN ident.taxonrank; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.taxonrank IS 'Ranking taxonômico.';


--
-- Name: COLUMN ident.infraspecificepithet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.infraspecificepithet IS 'Epíteto infraespecífico.';


--
-- Name: COLUMN ident.vernacularname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.vernacularname IS 'Nome comum.';


--
-- Name: COLUMN ident.identificationremarks; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.identificationremarks IS 'Observações.';


--
-- Name: COLUMN ident.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ident.status IS 'Status da identificação: pendente, valido ou invalido..';


--
-- Name: ident_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ident_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ident_id_seq OWNER TO postgres;

--
-- Name: ident_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ident_id_seq OWNED BY public.ident.id;


--
-- Name: ident_view; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.ident_view AS
 SELECT i.id,
    i.record_id,
    i.user_id,
    i.identifiedby_id,
    i.dateidentified,
    i.validatedby_id,
    i.datevalidated,
    i.scientificname,
    i.scientificnameauthorship,
    i.kingdom,
    i.phylum,
    i.class,
    i.ordem,
    i.family,
    i.genus,
    i.subgenus,
    i.specificepithet,
    i.taxonrank,
    i.infraspecificepithet,
    i.vernacularname,
    i.identificationremarks,
    i.status
   FROM public.ident i
  WHERE ((i.status = 'valido'::public.ident_status_type) AND (i.kingdom = 'animalia'::text) AND (i.datevalidated = ( SELECT max(ident.datevalidated) AS max
           FROM public.ident
          WHERE ((ident.record_id = i.record_id) AND (ident.kingdom = 'animalia'::text) AND (ident.status = 'valido'::public.ident_status_type)))))
UNION
 SELECT j.id,
    j.record_id,
    j.user_id,
    j.identifiedby_id,
    j.dateidentified,
    j.validatedby_id,
    j.datevalidated,
    j.scientificname,
    j.scientificnameauthorship,
    j.kingdom,
    j.phylum,
    j.class,
    j.ordem,
    j.family,
    j.genus,
    j.subgenus,
    j.specificepithet,
    j.taxonrank,
    j.infraspecificepithet,
    j.vernacularname,
    j.identificationremarks,
    j.status
   FROM public.ident j
  WHERE ((j.status = 'valido'::public.ident_status_type) AND (j.kingdom = 'plantae'::text) AND (j.datevalidated = ( SELECT max(ident.datevalidated) AS max
           FROM public.ident
          WHERE ((ident.record_id = j.record_id) AND (ident.kingdom = 'plantae'::text) AND (ident.status = 'valido'::public.ident_status_type)))));


ALTER TABLE public.ident_view OWNER TO postgres;

--
-- Name: image; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.image (
    id integer NOT NULL,
    record_id integer,
    user_id integer,
    code text NOT NULL,
    format text NOT NULL,
    sequence smallint NOT NULL,
    image_of public.image_type DEFAULT 'interacao'::public.image_type NOT NULL
);


ALTER TABLE public.image OWNER TO postgres;

--
-- Name: TABLE image; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.image IS 'Metadados das imagens associadas aos registros.';


--
-- Name: COLUMN image.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.image.id IS 'Chave primária.';


--
-- Name: COLUMN image.record_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.image.record_id IS 'Registro de observação associado.';


--
-- Name: COLUMN image.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.image.user_id IS 'Chave do usuário';


--
-- Name: COLUMN image.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.image.code IS 'Código usado para dar nome a cada imagem enviada';


--
-- Name: COLUMN image.format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.image.format IS 'Formato (ex: jpg).';


--
-- Name: COLUMN image.sequence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.image.sequence IS 'Sequência da imagem.';


--
-- Name: COLUMN image.image_of; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.image.image_of IS 'Objeto da imagem: interacao ou planta.';


--
-- Name: image_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.image_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.image_id_seq OWNER TO postgres;

--
-- Name: image_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.image_id_seq OWNED BY public.image.id;


--
-- Name: map_projects; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.map_projects (
    gid integer NOT NULL,
    id numeric(10,0),
    nome character varying(100),
    geom public.geometry(MultiPolygon,4326)
);


ALTER TABLE public.map_projects OWNER TO postgres;

--
-- Name: TABLE map_projects; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.map_projects IS 'Áreas de atuação dos projetos parceiros.';


--
-- Name: COLUMN map_projects.gid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_projects.gid IS 'Chave primária.';


--
-- Name: COLUMN map_projects.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_projects.id IS 'Identificador (?).';


--
-- Name: COLUMN map_projects.nome; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_projects.nome IS 'Nome do projeto.';


--
-- Name: COLUMN map_projects.geom; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_projects.geom IS 'Delimitação geográfica.';


--
-- Name: map_ucsfi; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.map_ucsfi (
    gid integer NOT NULL,
    codigocnuc character varying(15),
    nome character varying(254),
    geometriaa character varying(4),
    anocriacao smallint,
    sigla character varying(6),
    areaha numeric,
    perimetrom numeric,
    atolegal character varying(254),
    administra character varying(30),
    siglagrupo character varying(2),
    uf character varying(9),
    municipios character varying(254),
    biomaibge character varying(50),
    biomacrl character varying(100),
    coordregio character varying(100),
    uorg smallint,
    geom public.geometry(MultiPolygon,4326)
);


ALTER TABLE public.map_ucsfi OWNER TO postgres;

--
-- Name: TABLE map_ucsfi; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.map_ucsfi IS 'Unidades de Conservação Federais.Unidades de Conservação Federais. Fonte: http://www.icmbio.gov.br/portal/geoprocessamentos/51-menu-servicos/4004-downloads-mapa-tematico-e-dados-geoestatisticos-das-uc-s  opção Unidades de Conservação Federais – SHP (SIRGAS2000), convertida para PostGIS com o comando: "shp2pgsql -s 4326 -I UCs_fed_junho_2018.shp map_ucsfi > map_ucsfi.sql", nomes das UCs transformados com "update map_ucsfi set nome = initcap(nome)".';


--
-- Name: COLUMN map_ucsfi.gid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.gid IS 'Chave primária.';


--
-- Name: COLUMN map_ucsfi.codigocnuc; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.codigocnuc IS 'Código da UC.';


--
-- Name: COLUMN map_ucsfi.nome; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.nome IS 'Nome da UC.';


--
-- Name: COLUMN map_ucsfi.anocriacao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.anocriacao IS 'Ano de criação.';


--
-- Name: COLUMN map_ucsfi.sigla; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.sigla IS 'Sigla da UC.';


--
-- Name: COLUMN map_ucsfi.areaha; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.areaha IS 'Área em hectares.';


--
-- Name: COLUMN map_ucsfi.perimetrom; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.perimetrom IS 'Perímetro em metros.';


--
-- Name: COLUMN map_ucsfi.atolegal; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.atolegal IS 'Legislação que criou a UC.';


--
-- Name: COLUMN map_ucsfi.administra; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.administra IS 'Esfera de administração (federal, estadual...).';


--
-- Name: COLUMN map_ucsfi.uf; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.uf IS 'Unidades de federação envolvidas.';


--
-- Name: COLUMN map_ucsfi.municipios; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.municipios IS 'Municípios envolvidos.';


--
-- Name: COLUMN map_ucsfi.biomaibge; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.biomaibge IS 'Bioma de acordo com o IBGE.';


--
-- Name: COLUMN map_ucsfi.coordregio; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.coordregio IS 'Coordenação regional.';


--
-- Name: COLUMN map_ucsfi.geom; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ucsfi.geom IS 'Representação geográfica da UC.';


--
-- Name: map_ucsfi_gid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.map_ucsfi_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.map_ucsfi_gid_seq OWNER TO postgres;

--
-- Name: map_ucsfi_gid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.map_ucsfi_gid_seq OWNED BY public.map_ucsfi.gid;


--
-- Name: map_ufs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.map_ufs (
    gid integer NOT NULL,
    id double precision,
    cd_geocodu character varying(2),
    nome_estado character varying(50),
    nome_regiao character varying(20),
    geom public.geometry(MultiPolygonM,4326),
    sigla_estado text,
    sigla_regiao text
);


ALTER TABLE public.map_ufs OWNER TO postgres;

--
-- Name: TABLE map_ufs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.map_ufs IS 'Unidades da Federação.';


--
-- Name: COLUMN map_ufs.gid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ufs.gid IS 'Chave primária.';


--
-- Name: COLUMN map_ufs.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ufs.id IS 'Identificador.';


--
-- Name: COLUMN map_ufs.cd_geocodu; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ufs.cd_geocodu IS 'Código.';


--
-- Name: COLUMN map_ufs.nome_estado; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ufs.nome_estado IS 'Nome.';


--
-- Name: COLUMN map_ufs.nome_regiao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ufs.nome_regiao IS 'Nome da região.';


--
-- Name: COLUMN map_ufs.geom; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ufs.geom IS 'Representação geográfica.';


--
-- Name: COLUMN map_ufs.sigla_estado; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ufs.sigla_estado IS 'Sigla.';


--
-- Name: COLUMN map_ufs.sigla_regiao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.map_ufs.sigla_regiao IS 'Sigla da região.';


--
-- Name: map_ufs_gid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.map_ufs_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.map_ufs_gid_seq OWNER TO postgres;

--
-- Name: map_ufs_gid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.map_ufs_gid_seq OWNED BY public.map_ufs.gid;


--
-- Name: map_world; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.map_world (
    gid integer NOT NULL,
    uid integer,
    gid_0 character varying(80),
    id_0 integer,
    name_0 character varying(80),
    gid_1 character varying(80),
    id_1 integer,
    name_1 character varying(80),
    varname_1 character varying(129),
    nl_name_1 character varying(87),
    hasc_1 character varying(80),
    cc_1 character varying(80),
    type_1 character varying(80),
    engtype_1 character varying(80),
    validfr_1 character varying(80),
    validto_1 character varying(80),
    remarks_1 character varying(97),
    gid_2 character varying(80),
    id_2 integer,
    name_2 character varying(80),
    varname_2 character varying(116),
    nl_name_2 character varying(80),
    hasc_2 character varying(80),
    cc_2 character varying(80),
    type_2 character varying(80),
    engtype_2 character varying(80),
    validfr_2 character varying(80),
    validto_2 character varying(80),
    remarks_2 character varying(97),
    gid_3 character varying(80),
    id_3 integer,
    name_3 character varying(80),
    varname_3 character varying(80),
    nl_name_3 character varying(80),
    hasc_3 character varying(80),
    cc_3 character varying(80),
    type_3 character varying(80),
    engtype_3 character varying(80),
    validfr_3 character varying(80),
    validto_3 character varying(80),
    remarks_3 character varying(80),
    gid_4 character varying(80),
    id_4 integer,
    name_4 character varying(98),
    varname_4 character varying(80),
    cc_4 character varying(80),
    type_4 character varying(80),
    engtype_4 character varying(80),
    validfr_4 character varying(80),
    validto_4 character varying(80),
    remarks_4 character varying(80),
    gid_5 character varying(80),
    id_5 integer,
    name_5 character varying(80),
    cc_5 character varying(80),
    type_5 character varying(80),
    engtype_5 character varying(80),
    region character varying(80),
    varregion character varying(80),
    zone integer,
    geom public.geometry(MultiPolygon,4326)
);


ALTER TABLE public.map_world OWNER TO postgres;

--
-- Name: TABLE map_world; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.map_world IS 'Mapa completo administrativo do mundo. Fonte: https://gadm.org/download_world.html . Baixada a opção "whole world" em shapefile. Convertida com "shp2pgsql -s 4326 -I gadm36.shp map_world > map_world.sql"';


--
-- Name: map_world_gid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.map_world_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.map_world_gid_seq OWNER TO postgres;

--
-- Name: map_world_gid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.map_world_gid_seq OWNED BY public.map_world.gid;


--
-- Name: netids; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.netids (
    user_id integer NOT NULL,
    netid text NOT NULL,
    network text NOT NULL
);


ALTER TABLE public.netids OWNER TO postgres;

--
-- Name: TABLE netids; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.netids IS 'Cadastro de usuário em rede social.';


--
-- Name: COLUMN netids.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.netids.user_id IS 'Chave do usuário.';


--
-- Name: COLUMN netids.netid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.netids.netid IS 'Código do usuário na rede social.';


--
-- Name: COLUMN netids.network; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.netids.network IS 'Rede social (facebook, twitter, instagram ou google).';


--
-- Name: new_projects_gid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.new_projects_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.new_projects_gid_seq OWNER TO postgres;

--
-- Name: new_projects_gid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.new_projects_gid_seq OWNED BY public.map_projects.gid;


--
-- Name: record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.record (
    id integer NOT NULL,
    record_date timestamp with time zone DEFAULT now(),
    record_modified timestamp with time zone DEFAULT now(),
    user_id integer,
    country text NOT NULL,
    stateprovince text NOT NULL,
    municipality text NOT NULL,
    locality text DEFAULT ''::text,
    decimallatitude text DEFAULT ''::text,
    decimallongitude text DEFAULT ''::text,
    elevation text DEFAULT ''::text,
    verbatimeventdate text DEFAULT ''::text,
    eventdate text DEFAULT ''::text,
    eventtime text DEFAULT ''::text,
    eventremarks text DEFAULT ''::text,
    point public.geometry(Point,4326) DEFAULT NULL::public.geometry,
    taxgrp text DEFAULT ''::text,
    habit text DEFAULT ''::text NOT NULL,
    interaction text DEFAULT ''::text NOT NULL,
    datum text DEFAULT ''::text,
    eventday integer DEFAULT 0,
    eventmonth integer DEFAULT 0,
    eventyear integer DEFAULT 0
);


ALTER TABLE public.record OWNER TO postgres;

--
-- Name: TABLE record; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.record IS 'Registro de observação.';


--
-- Name: COLUMN record.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.id IS 'Chave primária.';


--
-- Name: COLUMN record.record_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.record_date IS 'Data do registro.';


--
-- Name: COLUMN record.record_modified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.record_modified IS 'Data de modificação do registro.';


--
-- Name: COLUMN record.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.user_id IS 'Usuário associado.';


--
-- Name: COLUMN record.country; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.country IS 'País.';


--
-- Name: COLUMN record.stateprovince; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.stateprovince IS 'Estado.';


--
-- Name: COLUMN record.municipality; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.municipality IS 'Município.';


--
-- Name: COLUMN record.locality; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.locality IS 'Localidade.';


--
-- Name: COLUMN record.decimallatitude; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.decimallatitude IS 'Latitude em graus decimais.';


--
-- Name: COLUMN record.decimallongitude; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.decimallongitude IS 'Longitude em graus decimais.';


--
-- Name: COLUMN record.elevation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.elevation IS 'Elevação em metros.';


--
-- Name: COLUMN record.verbatimeventdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.verbatimeventdate IS 'Data/hora original da observação.';


--
-- Name: COLUMN record.eventdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.eventdate IS 'Data da observação (dd/mm/aaaa).';


--
-- Name: COLUMN record.eventtime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.eventtime IS 'Hora da observação.';


--
-- Name: COLUMN record.eventremarks; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.eventremarks IS 'Observações.';


--
-- Name: COLUMN record.point; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.point IS 'Representação geométrica do ponto.';


--
-- Name: COLUMN record.taxgrp; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.taxgrp IS 'Tipo de animal de acordo com as definições em def_expertise (key).';


--
-- Name: COLUMN record.habit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.habit IS 'Hábito da planta de acordo com as definições em def_habit.';


--
-- Name: COLUMN record.interaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.interaction IS 'Tipo de interação de acordo com as definições em def_interaction.';


--
-- Name: COLUMN record.datum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.datum IS 'Datum das coordenadas.';


--
-- Name: COLUMN record.eventday; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.eventday IS 'Dia da observação.';


--
-- Name: COLUMN record.eventmonth; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.eventmonth IS 'Mês da observação.';


--
-- Name: COLUMN record.eventyear; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.record.eventyear IS 'Ano da observação.';


--
-- Name: record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.record_id_seq OWNER TO postgres;

--
-- Name: record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.record_id_seq OWNED BY public.record.id;


--
-- Name: session; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.session (
    session_id text NOT NULL,
    user_id integer,
    last_seen timestamp with time zone DEFAULT now(),
    network text NOT NULL
);


ALTER TABLE public.session OWNER TO postgres;

--
-- Name: TABLE session; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.session IS 'Controle de sessão.';


--
-- Name: COLUMN session.session_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.session.session_id IS 'Chave primária.';


--
-- Name: COLUMN session.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.session.user_id IS 'Chave do usuário.';


--
-- Name: COLUMN session.last_seen; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.session.last_seen IS 'Última utilização da sessão.';


--
-- Name: COLUMN session.network; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.session.network IS 'Local onde foi feito o login (guardioes, google, facebook, twitter ou instagram).';


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id integer NOT NULL,
    name text NOT NULL,
    nickname text,
    email text,
    password text,
    birthday integer,
    gender text,
    picture text,
    language text DEFAULT 'pt'::text,
    education public.education_type DEFAULT 'fundamental'::public.education_type NOT NULL,
    since timestamp with time zone DEFAULT now(),
    flags text,
    curriculum text,
    category public.category_type DEFAULT 'guardiao'::public.category_type NOT NULL,
    status public.status_type DEFAULT 'ativo'::public.status_type NOT NULL,
    comments text,
    agreement boolean DEFAULT false,
    terms_guardiao timestamp with time zone,
    alert_period text DEFAULT 'never'::text,
    last_alert timestamp with time zone DEFAULT now(),
    last_seen timestamp with time zone DEFAULT now(),
    terms_especialista timestamp with time zone,
    is_super boolean DEFAULT false,
    is_admin boolean DEFAULT false
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Name: TABLE users; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.users IS 'Usuários.';


--
-- Name: COLUMN users.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.id IS 'Chave primária.';


--
-- Name: COLUMN users.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.name IS 'Nome.';


--
-- Name: COLUMN users.nickname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.nickname IS 'Apelido.';


--
-- Name: COLUMN users.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.email IS 'E-mail.';


--
-- Name: COLUMN users.password; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.password IS 'Senha criptografada.';


--
-- Name: COLUMN users.birthday; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.birthday IS 'Data de aniversário (formato AAAAMMDD).';


--
-- Name: COLUMN users.gender; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.gender IS 'Gênero (male ou female).';


--
-- Name: COLUMN users.picture; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.picture IS 'Nome do arquivo local com a foto do usuário.';


--
-- Name: COLUMN users.language; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.language IS 'Idioma de preferência (pt ou en).';


--
-- Name: COLUMN users.education; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.education IS 'Escolaridade (fundamental, medio, superior ou pos).';


--
-- Name: COLUMN users.since; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.since IS 'Data/hora de cadastro no sistema.';


--
-- Name: COLUMN users.curriculum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.curriculum IS 'Link para o currículo.';


--
-- Name: COLUMN users.category; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.category IS 'Tipo de usuário (guardiao, especialista, admin ou super).';


--
-- Name: COLUMN users.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.status IS 'Status do usuario: ativo, pendente, inativo...';


--
-- Name: COLUMN users.comments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.comments IS 'Comentários associados à inscrição do usuário';


--
-- Name: COLUMN users.agreement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.agreement IS 'Usuário aceita ou não os termos de uso dos guardiões';


--
-- Name: COLUMN users.terms_guardiao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.terms_guardiao IS 'Data de aceite dos termos de uso dos guardiões';


--
-- Name: COLUMN users.alert_period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.alert_period IS 'Frequência com que o usuário aceita receber notificações (day, week, never).';


--
-- Name: COLUMN users.last_alert; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.last_alert IS 'Data/hora de envio da última notificação.';


--
-- Name: COLUMN users.last_seen; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.last_seen IS 'Data/hora do último login.';


--
-- Name: COLUMN users.is_super; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.is_super IS 'Usuário é super usuário do sistema';


--
-- Name: COLUMN users.is_admin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.is_admin IS 'Usuário é administrador dos guardiões';


--
-- Name: users_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.users_id_seq OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.users_id_seq OWNED BY public.users.id;


--
-- Name: device id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.device ALTER COLUMN id SET DEFAULT nextval('public.device_id_seq'::regclass);


--
-- Name: ident id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ident ALTER COLUMN id SET DEFAULT nextval('public.ident_id_seq'::regclass);


--
-- Name: image id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.image ALTER COLUMN id SET DEFAULT nextval('public.image_id_seq'::regclass);


--
-- Name: map_projects gid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.map_projects ALTER COLUMN gid SET DEFAULT nextval('public.new_projects_gid_seq'::regclass);


--
-- Name: map_ucsfi gid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.map_ucsfi ALTER COLUMN gid SET DEFAULT nextval('public.map_ucsfi_gid_seq'::regclass);


--
-- Name: map_ufs gid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.map_ufs ALTER COLUMN gid SET DEFAULT nextval('public.map_ufs_gid_seq'::regclass);


--
-- Name: map_world gid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.map_world ALTER COLUMN gid SET DEFAULT nextval('public.map_world_gid_seq'::regclass);


--
-- Name: record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.record ALTER COLUMN id SET DEFAULT nextval('public.record_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users ALTER COLUMN id SET DEFAULT nextval('public.users_id_seq'::regclass);


--
-- Name: def_expertise def_expertise_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.def_expertise
    ADD CONSTRAINT def_expertise_pkey PRIMARY KEY (id);


--
-- Name: def_habit def_habit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.def_habit
    ADD CONSTRAINT def_habit_pkey PRIMARY KEY (id);


--
-- Name: def_interaction def_interaction_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.def_interaction
    ADD CONSTRAINT def_interaction_pkey PRIMARY KEY (id);


--
-- Name: device device_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.device
    ADD CONSTRAINT device_pkey PRIMARY KEY (id);


--
-- Name: ident ident_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ident
    ADD CONSTRAINT ident_pkey PRIMARY KEY (id);


--
-- Name: image image_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.image
    ADD CONSTRAINT image_pkey PRIMARY KEY (id);


--
-- Name: map_ucsfi map_ucsfi_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.map_ucsfi
    ADD CONSTRAINT map_ucsfi_pkey PRIMARY KEY (gid);


--
-- Name: map_ufs map_ufs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.map_ufs
    ADD CONSTRAINT map_ufs_pkey PRIMARY KEY (gid);


--
-- Name: map_world map_world_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.map_world
    ADD CONSTRAINT map_world_pkey PRIMARY KEY (gid);


--
-- Name: map_projects new_projects_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.map_projects
    ADD CONSTRAINT new_projects_pkey PRIMARY KEY (gid);


--
-- Name: record record_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.record
    ADD CONSTRAINT record_pkey PRIMARY KEY (id);


--
-- Name: session session_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.session
    ADD CONSTRAINT session_pkey PRIMARY KEY (session_id);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: appcode_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX appcode_idx ON public.device USING btree (appcode);


--
-- Name: counts_user_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX counts_user_id_idx ON public.counts USING btree (user_id);


--
-- Name: map_ucsfi_geom_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX map_ucsfi_geom_idx ON public.map_ucsfi USING gist (geom);


--
-- Name: map_ufs_geom_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX map_ufs_geom_idx ON public.map_ufs USING gist (geom);


--
-- Name: map_world_geom_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX map_world_geom_idx ON public.map_world USING gist (geom);


--
-- Name: new_projects_geom_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX new_projects_geom_idx ON public.map_projects USING gist (geom);


--
-- Name: user_netid_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX user_netid_pkey ON public.netids USING btree (netid, network);


--
-- Name: users_email_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX users_email_idx ON public.users USING btree (email);


--
-- Name: def_expertise def_version_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER def_version_trigger BEFORE INSERT OR DELETE OR UPDATE ON public.def_expertise FOR EACH ROW EXECUTE FUNCTION public.def_version_trigger_function();


--
-- Name: def_habit def_version_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER def_version_trigger BEFORE INSERT OR DELETE OR UPDATE ON public.def_habit FOR EACH ROW EXECUTE FUNCTION public.def_version_trigger_function();


--
-- Name: def_interaction def_version_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER def_version_trigger BEFORE INSERT OR DELETE OR UPDATE ON public.def_interaction FOR EACH ROW EXECUTE FUNCTION public.def_version_trigger_function();


--
-- Name: record eventdateupdatetriggeronrecord; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER eventdateupdatetriggeronrecord BEFORE INSERT OR UPDATE ON public.record FOR EACH ROW EXECUTE FUNCTION public.eventdateupdate();


--
-- Name: ident updatecountstriggeronident; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER updatecountstriggeronident AFTER INSERT OR DELETE OR UPDATE ON public.ident FOR EACH ROW EXECUTE FUNCTION public.updatecounts();


--
-- Name: record updatecountstriggeronrecord; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER updatecountstriggeronrecord AFTER INSERT OR DELETE OR UPDATE ON public.record FOR EACH ROW EXECUTE FUNCTION public.updatecounts();


--
-- Name: device device_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.device
    ADD CONSTRAINT device_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: expertises expertises_expertise_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.expertises
    ADD CONSTRAINT expertises_expertise_id_fkey FOREIGN KEY (expertise_id) REFERENCES public.def_expertise(id);


--
-- Name: expertises expertises_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.expertises
    ADD CONSTRAINT expertises_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: ident ident_identifiedby_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ident
    ADD CONSTRAINT ident_identifiedby_id_fkey FOREIGN KEY (identifiedby_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: ident ident_record_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ident
    ADD CONSTRAINT ident_record_id_fkey FOREIGN KEY (record_id) REFERENCES public.record(id) ON DELETE CASCADE;


--
-- Name: ident ident_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ident
    ADD CONSTRAINT ident_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: ident ident_validatedby_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ident
    ADD CONSTRAINT ident_validatedby_id_fkey FOREIGN KEY (validatedby_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: image image_record_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.image
    ADD CONSTRAINT image_record_id_fkey FOREIGN KEY (record_id) REFERENCES public.record(id) ON DELETE CASCADE;


--
-- Name: image image_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.image
    ADD CONSTRAINT image_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: netids netids_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.netids
    ADD CONSTRAINT netids_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: record record_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.record
    ADD CONSTRAINT record_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: session session_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.session
    ADD CONSTRAINT session_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--

